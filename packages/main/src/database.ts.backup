import { app } from "electron";
import path from "path";
import fs from "fs";
import { createRequire } from "module";
import { fileURLToPath } from "url";

const require = createRequire(import.meta.url);
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

import type {
  User,
  Permission,
  Business,
  Session,
  Product,
  Modifier,
  ModifierOption,
  StockAdjustment,
  Supplier,
  Category,
  Schedule,
  Shift,
  Transaction,
  TransactionItem,
  RefundItem,
  AppliedModifier,
  CashDrawerCount,
  ShiftReport,
  ClockEvent,
  TimeShift,
  Break,
  TimeCorrection,
  AuditLog,
  AttendanceReport,
  ShiftValidation,
} from "../../../types/database.d.ts";

// Re-export types for use in other modules
export type {
  User,
  Permission,
  Business,
  Session,
  Product,
  Modifier,
  ModifierOption,
  StockAdjustment,
  Supplier,
  Category,
  Schedule,
  Shift,
  Transaction,
  TransactionItem,
  RefundItem,
  AppliedModifier,
  CashDrawerCount,
  ShiftReport,
  ClockEvent,
  TimeShift,
  Break,
  TimeCorrection,
  AuditLog,
  AttendanceReport,
  ShiftValidation,
};

import { initializeDrizzle, type DrizzleDB } from "./database/drizzle.js";
import { eq, and, like, desc, asc, sql as drizzleSql } from "drizzle-orm";
import * as schema from "./database/schema.js";

// Import all managers
import { UserManager } from "./database/managers/userManager.js";
import { ProductManager } from "./database/managers/productManager.js";
import { TransactionManager } from "./database/managers/transactionManager.js";
import { CategoryManager } from "./database/managers/categoryManager.js";
import { ShiftManager } from "./database/managers/shiftManager.js";
import { ScheduleManager } from "./database/managers/scheduleManager.js";
import { SessionManager } from "./database/managers/sessionManager.js";
import { AuditLogManager } from "./database/managers/auditLogManager.js";
import { ReportManager } from "./database/managers/reportManager.js";
import { BusinessManager } from "./database/managers/businessManager.js";
import { CashDrawerManager } from "./database/managers/cashDrawerManager.js";
import { DiscountManager } from "./database/managers/discountManager.js";
import { InventoryManager } from "./database/managers/inventoryManager.js";
import { SupplierManager } from "./database/managers/supplierManager.js";
import { TimeTrackingManager } from "./database/managers/timeTrackingManager.js";
import { AuditManager } from "./database/managers/auditManager.js";
import { TimeTrackingReportManager } from "./database/managers/timeTrackingReportManager.js";
import { SettingsManager } from "./database/managers/settingsManager.js";

export class DatabaseManager {
  private db: any;
  private drizzle: DrizzleDB | null = null;
  private bcrypt: any;
  private uuid: any;
  private initialized: boolean = false;

  // Manager instances - exposed as public properties
  public users!: UserManager;
  public products!: ProductManager;
  public transactions!: TransactionManager;
  public categories!: CategoryManager;
  public shifts!: ShiftManager;
  public schedules!: ScheduleManager;
  public sessions!: SessionManager;
  public auditLogs!: AuditLogManager;
  public reports!: ReportManager;
  public businesses!: BusinessManager;
  public cashDrawers!: CashDrawerManager;
  public discounts!: DiscountManager;
  public inventory!: InventoryManager;
  public suppliers!: SupplierManager;
  public timeTracking!: TimeTrackingManager;
  public audit!: AuditManager;
  public timeTrackingReports!: TimeTrackingReportManager;
  public settings!: SettingsManager;

  constructor() {
    // Don't initialize here, wait for explicit initialization
  }

  async initialize() {
    if (this.initialized) return;

    try {
      const Database = require("better-sqlite3");
      const bcrypt = require("bcryptjs");
      const { v4: uuidv4 } = require("uuid");

      // bcryptjs exports functions directly, not as an object
      this.bcrypt = {
        hash: bcrypt.hash,
        compare: bcrypt.compare,
      };
      this.uuid = { v4: uuidv4 };

      const dbPath = this.getDatabasePath();
      console.log("Database path:", dbPath);

      // Ensure the directory exists
      const dbDir = path.dirname(dbPath);
      if (!fs.existsSync(dbDir)) {
        fs.mkdirSync(dbDir, { recursive: true });
      }

      this.db = new Database(dbPath);

      // Initialize Drizzle ORM with the same connection
      this.drizzle = initializeDrizzle(this.db);

      // Run Drizzle migrations automatically
      // This handles ALL schema creation and updates from .sql files
      const { runDrizzleMigrations } = await import(
        "./database/drizzle-migrator.js"
      );
      const migrationSuccess = await runDrizzleMigrations(this.drizzle, dbPath);

      if (!migrationSuccess) {
        throw new Error("Database migration failed");
      }

      // Initialize all managers with drizzle support
      this.initializeManagers();

      this.initialized = true;
      console.log("Database initialized successfully\n");
    } catch (error) {
      console.error(" Database initialization error:", error);
      throw error;
    }
  }

  /**
   * Initialize all manager instances with Drizzle ORM support
   * Managers provide domain-separated, type-safe access to database operations
   */
  private initializeManagers(): void {
    if (!this.drizzle) {
      throw new Error("Drizzle ORM must be initialized before managers");
    }

    console.log("Initializing managers with Drizzle ORM support...");

    // Initialize each manager with Drizzle instance only (pure Drizzle architecture)
    this.users = new UserManager(this.drizzle, this.bcrypt, this.uuid);
    this.products = new ProductManager(this.drizzle, this.uuid);
    this.transactions = new TransactionManager(this.drizzle, this.uuid);
    this.categories = new CategoryManager(this.drizzle, this.uuid);
    this.shifts = new ShiftManager(this.drizzle, this.uuid);
    this.schedules = new ScheduleManager(this.drizzle, this.uuid);
    this.sessions = new SessionManager(this.drizzle, this.uuid);
    this.auditLogs = new AuditLogManager(this.drizzle, this.uuid);
    this.reports = new ReportManager(this.drizzle);
    this.businesses = new BusinessManager(this.drizzle, this.uuid);
    this.cashDrawers = new CashDrawerManager(this.drizzle, this.uuid);
    this.discounts = new DiscountManager(this.drizzle, this.uuid);
    this.inventory = new InventoryManager(this.drizzle, this.uuid);
    this.suppliers = new SupplierManager(this.drizzle, this.uuid);
    this.timeTracking = new TimeTrackingManager(this.drizzle, this.uuid);
    this.audit = new AuditManager(this.drizzle, this.uuid);
    this.timeTrackingReports = new TimeTrackingReportManager(this.drizzle); // ⚠️ Partially converted: 10 complex aggregation queries remain
    this.settings = new SettingsManager(this.drizzle);

    console.log("✅ All managers initialized successfully");
  }

  private getDatabasePath(): string {
    // Multiple ways to detect development mode
    const isDev =
      process.env.NODE_ENV === "development" ||
      process.env.ELECTRON_IS_DEV === "true" ||
      !app.isPackaged;

    // Allow override via environment variable for testing
    const customDbPath = process.env.POS_DB_PATH;
    if (customDbPath) {
      console.log("Using custom database path:", customDbPath);
      return customDbPath;
    }

    if (isDev) {
      // Development: Store in project directory
      const projectRoot = path.join(__dirname, "..", "..", "..");
      const devDbPath = path.join(projectRoot, "data", "pos_system.db");
      console.log("Development mode: Using project directory for database");
      console.log("Database at:", devDbPath);
      return devDbPath;
    } else {
      // Production: Use proper user data directory based on platform
      const userDataPath = app.getPath("userData");
      const prodDbPath = path.join(userDataPath, "AuraSwift", "pos_system.db");
      console.log("Production mode: Using user data directory for database");
      console.log("Database at:", prodDbPath);
      return prodDbPath;
    }
  }

  /**
   * Get Drizzle ORM instance for type-safe queries
   * @throws Error if Drizzle hasn't been initialized
   */
  private getDrizzleInstance(): DrizzleDB {
    if (!this.drizzle) {
      throw new Error("Drizzle ORM not initialized. Call initialize() first.");
    }
    return this.drizzle;
  }

  // ============================================
  // FACADE METHODS - Delegate to managers
  // These methods maintain backward compatibility
  // while using the proper manager architecture
  // ============================================

  getUserByEmail(email: string): User | null {
    return this.users.getUserByEmail(email);
  }

  getUserByUsername(username: string): User | null {
    return this.users.getUserByUsername(username);
  }

  getUserById(id: string): User | null {
    return this.users.getUserById(id);
  }

  async authenticateUser(username: string, pin: string): Promise<User | null> {
    return this.users.authenticateUserByUsernamePin(username, pin);
  }

  // Session management methods
  // Session methods - delegate to SessionManager
  createOrUpdateSession(token: string, value: string): void {
    return this.sessions.createOrUpdateSession(token, value);
  }

  getSessionByToken(token: string): Session | null {
    return this.sessions.getSessionByToken(token);
  }

  deleteSessionByToken(token: string): void {
    return this.sessions.deleteSessionByToken(token);
  }

  createSession(userId: string, expiryDays: number = 7): Session {
    return this.sessions.createSession(userId, expiryDays);
  }

  deleteSession(token: string): boolean {
    return this.sessions.deleteSession(token);
  }

  deleteUserSessions(userId: string): number {
    return this.sessions.deleteUserSessions(userId);
  }

  cleanupExpiredSessions(): number {
    return this.sessions.cleanupExpiredSessions();
  }

  // Business management methods
  getBusinessById(id: string): Business | null {
    return this.businesses.getBusinessById(id);
  }

  updateBusiness(
    id: string,
    updates: Partial<{
      name: string;
      address: string;
      phone: string;
      vatNumber: string;
    }>
  ): boolean {
    return this.businesses.updateBusiness(id, updates);
  }

  getUsersByBusiness(businessId: string): User[] {
    const users = this.db
      .prepare(
        `
      SELECT * FROM users 
      WHERE businessId = ? AND isActive = 1
      ORDER BY createdAt DESC
    `
      )
      .all(businessId) as any[];

    return users.map((user) => ({
      ...user,
      permissions: JSON.parse(user.permissions),
    }));
  }

  // ============================================
  // CATEGORY METHODS - Delegate to CategoryManager
  // ============================================

  async createCategory(categoryData: {
    name: string;
    description?: string;
    businessId: string;
    sortOrder?: number;
    parentId?: string | null;
  }): Promise<Category> {
    return this.categories.createCategory(categoryData);
  }

  async getCategoryById(id: string): Promise<Category> {
    return this.categories.getCategoryById(id);
  }

  async getCategoriesByBusiness(businessId: string): Promise<Category[]> {
    return this.categories.getCategoriesByBusiness(businessId);
  }

  async searchCategories(
    businessId: string,
    searchTerm: string
  ): Promise<Category[]> {
    return this.categories.searchCategories(businessId, searchTerm);
  }

  async getCategoryHierarchy(businessId: string) {
    return this.categories.getCategoryHierarchy(businessId);
  }

  async updateCategory(
    id: string,
    updates: Partial<{
      name: string;
      description: string;
      parentId: string | null;
      sortOrder: number;
      isActive: boolean;
    }>
  ): Promise<Category> {
    return this.categories.updateCategory(id, updates);
  }

  async deleteCategory(id: string): Promise<boolean> {
    return this.categories.deleteCategory(id);
  }

  async reorderCategories(
    businessId: string,
    categoryIds: string[]
  ): Promise<void> {
    return this.categories.reorderCategories(businessId, categoryIds);
  }

  async createDefaultCategories(businessId: string): Promise<void> {
    return this.categories.createDefaultCategories(businessId);
  }

  // ============================================
  // PRODUCT METHODS - Delegate to ProductManager
  // ============================================

  async createProduct(
    productData: Omit<Product, "id" | "createdAt" | "updatedAt" | "modifiers">
  ): Promise<Product> {
    return this.products.createProduct(productData);
  }

  async getProductById(id: string): Promise<Product> {
    return this.products.getProductById(id);
  }

  async getProductByPLU(plu: string): Promise<Product> {
    return this.products.getProductByPLU(plu);
  }

  async getProductsByBusiness(businessId: string): Promise<Product[]> {
    return this.products.getProductsByBusiness(businessId);
  }

  async searchProducts(
    businessId: string,
    searchTerm: string
  ): Promise<Product[]> {
    return this.products.searchProducts(businessId, searchTerm);
  }

  async getProductsWithCategory(businessId: string) {
    return this.products.getProductsWithCategory(businessId);
  }

  async getLowStockProducts(
    businessId: string,
    threshold?: number
  ): Promise<Product[]> {
    return this.products.getLowStockProducts(businessId, threshold);
  }

  async updateProduct(
    id: string,
    updates: Partial<Omit<Product, "id" | "createdAt" | "modifiers">>
  ): Promise<Product> {
    return this.products.updateProduct(id, updates);
  }

  async deleteProduct(id: string): Promise<boolean> {
    return this.products.deleteProduct(id);
  }

  async createModifier(
    modifierData: Omit<Modifier, "id" | "createdAt" | "updatedAt" | "options">
  ): Promise<Modifier> {
    return this.products.createModifier(modifierData);
  }

  async getModifierById(id: string): Promise<Modifier> {
    return this.products.getModifierById(id);
  }

  async createModifierOption(
    modifierId: string,
    optionData: Omit<ModifierOption, "id" | "createdAt">
  ): Promise<ModifierOption> {
    return this.products.createModifierOption(modifierId, optionData);
  }

  async getProductModifiers(productId: string): Promise<Modifier[]> {
    return this.products.getProductModifiers(productId);
  }

  async addModifierToProduct(
    productId: string,
    modifierId: string
  ): Promise<void> {
    return this.products.addModifierToProduct(productId, modifierId);
  }

  async removeModifierFromProduct(
    productId: string,
    modifierId: string
  ): Promise<void> {
    return this.products.removeModifierFromProduct(productId, modifierId);
  }

  /**
   * Create stock adjustment and update product stock
   */
  createStockAdjustment(
    adjustmentData: Omit<StockAdjustment, "id" | "timestamp">
  ): StockAdjustment {
    const adjustmentId = this.uuid.v4();
    const now = new Date().toISOString();

    // Start transaction
    const transaction = this.db.transaction(() => {
      // Create adjustment record
      this.db
        .prepare(
          `
        INSERT INTO stock_adjustments (id, productId, type, quantity, reason, userId, businessId, timestamp)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `
        )
        .run(
          adjustmentId,
          adjustmentData.productId,
          adjustmentData.type,
          adjustmentData.quantity,
          adjustmentData.reason,
          adjustmentData.userId,
          adjustmentData.businessId,
          now
        );

      // Update product stock level
      const stockChange =
        adjustmentData.type === "add"
          ? adjustmentData.quantity
          : -adjustmentData.quantity;
      this.db
        .prepare(
          `
        UPDATE products 
        SET stockLevel = MAX(0, stockLevel + ?), updatedAt = ?
        WHERE id = ?
      `
        )
        .run(stockChange, now, adjustmentData.productId);
    });

    transaction();

    return {
      id: adjustmentId,
      ...adjustmentData,
      timestamp: now,
    };
  }

  // ============================================
  // Settings Management - Delegate to SettingsManager
  // ============================================

  setSetting(key: string, value: string): void {
    return this.settings.setSetting(key, value);
  }

  getSetting(key: string): string | null {
    return this.settings.getSetting(key);
  }

  deleteSetting(key: string): void {
    return this.settings.deleteSetting(key);
  }

  clearAllSettings(): void {
    return this.settings.clearAllSettings();
  }

  // Schedule Management Methods - Delegate to ScheduleManager
  createSchedule(
    schedule: Omit<Schedule, "id" | "createdAt" | "updatedAt">
  ): Schedule {
    return this.schedules.createSchedule(schedule);
  }

  getSchedulesByBusinessId(businessId: string): Schedule[] {
    return this.schedules.getSchedulesByBusiness(businessId);
  }

  getSchedulesByStaffId(staffId: string): Schedule[] {
    return this.schedules.getSchedulesByStaffId(staffId);
  }

  updateScheduleStatus(scheduleId: string, status: Schedule["status"]): void {
    return this.schedules.updateScheduleStatus(scheduleId, status);
  }

  updateSchedule(
    scheduleId: string,
    updates: Partial<
      Pick<
        Schedule,
        | "staffId"
        | "startTime"
        | "endTime"
        | "assignedRegister"
        | "notes"
        | "status"
      >
    >
  ): Schedule {
    return this.schedules.updateSchedule(scheduleId, updates);
  }

  deleteSchedule(scheduleId: string): void {
    return this.schedules.deleteSchedule(scheduleId);
  }

  // ============================================
  // Shift Management Methods - Delegate to ShiftManager
  // ============================================
  createShift(shift: Omit<Shift, "id" | "createdAt" | "updatedAt">): Shift {
    return this.shifts.createShift(shift);
  }

  getActiveShiftByCashier(cashierId: string): Shift | null {
    return this.shifts.getActiveShift(cashierId);
  }

  getTodaysActiveShiftByCashier(cashierId: string): Shift | null {
    return this.shifts.getTodaysActiveShift(cashierId);
  }

  autoCloseOldActiveShifts(): number {
    return this.shifts.autoCloseOldActiveShifts();
  }

  autoEndOverdueShiftsToday(): number {
    return this.shifts.autoEndOverdueShiftsToday();
  }

  endShift(
    shiftId: string,
    endData: {
      endTime: string;
      finalCashDrawer: number;
      expectedCashDrawer: number;
      totalSales: number;
      totalTransactions: number;
      totalRefunds: number;
      totalVoids: number;
      notes?: string;
    }
  ): void {
    return this.shifts.endShift(shiftId, endData);
  }

  getShiftsByBusinessId(businessId: string): Shift[] {
    return this.shifts.getShiftsByBusiness(businessId);
  }

  getHourlyTransactionStats(shiftId: string): {
    lastHour: number;
    currentHour: number;
    averagePerHour: number;
  } {
    return this.shifts.getHourlyTransactionStats(shiftId);
  }

  getShiftById(shiftId: string): Shift | null {
    try {
      return this.shifts.getShiftById(shiftId);
    } catch {
      return null;
    }
  }

  reconcileShift(
    shiftId: string,
    reconciliationData: {
      actualCashDrawer: number;
      managerNotes: string;
      managerId: string;
    }
  ): void {
    return this.shifts.reconcileShift(shiftId, reconciliationData);
  }

  getPendingReconciliationShifts(businessId: string): Shift[] {
    return this.shifts.getPendingReconciliationShifts(businessId);
  }

  // Transaction Management Methods - Delegate to TransactionManager
  async createTransaction(
    transaction: Omit<Transaction, "id" | "createdAt">
  ): Promise<Transaction> {
    return this.transactions.createTransaction(transaction);
  }

  async createTransactionItem(
    transactionId: string,
    item: Omit<TransactionItem, "id" | "createdAt">
  ): Promise<string> {
    return this.transactions.createTransactionItem(transactionId, item);
  }

  async createAppliedModifier(
    transactionItemId: string,
    modifier: Omit<AppliedModifier, "id" | "createdAt">
  ): Promise<void> {
    return this.transactions.createAppliedModifier(transactionItemId, modifier);
  }

  async getTransactionsByShiftId(shiftId: string): Promise<Transaction[]> {
    return this.transactions.getTransactionsByShift(shiftId);
  }

  async getTransactionItems(transactionId: string): Promise<TransactionItem[]> {
    return this.transactions.getTransactionItems(transactionId);
  }

  async voidTransaction(voidData: {
    transactionId: string;
    cashierId: string;
    reason: string;
    managerApprovalId?: string;
  }): Promise<{
    success: boolean;
    message: string;
  }> {
    try {
      console.log(
        "Database: Starting void transaction for ID:",
        voidData.transactionId
      );

      // Get original transaction
      const originalTransaction = await this.getTransactionByIdAnyStatus(
        voidData.transactionId
      );
      console.log("Database: Original transaction:", originalTransaction);

      if (!originalTransaction) {
        throw new Error("Transaction not found");
      }

      // Check if transaction can be voided
      if (originalTransaction.status !== "completed") {
        console.log(
          "Database: Transaction status is not completed:",
          originalTransaction.status
        );
        throw new Error("Only completed transactions can be voided");
      }

      // Check time window (30 minutes for void)
      const transactionTime = new Date(originalTransaction.timestamp);
      const now = new Date();
      const timeDifferenceMinutes =
        (now.getTime() - transactionTime.getTime()) / (1000 * 60);

      console.log(
        "Database: Time difference in minutes:",
        timeDifferenceMinutes
      );

      if (timeDifferenceMinutes > 30 && !voidData.managerApprovalId) {
        throw new Error(
          "Transaction is older than 30 minutes and requires manager approval"
        );
      }

      // Update transaction status to voided
      console.log("Database: Updating transaction status to voided");
      const updateStmt = this.db.prepare(`
        UPDATE transactions 
        SET status = 'voided', voidReason = ?
        WHERE id = ?
      `);

      const now_iso = new Date().toISOString();
      const updateResult = updateStmt.run(
        voidData.reason,
        voidData.transactionId
      );
      console.log("Database: Update transaction result:", updateResult);

      // Restore inventory for all items in the transaction
      console.log(
        "Database: Restoring inventory for",
        originalTransaction.items.length,
        "items"
      );
      for (const item of originalTransaction.items) {
        const updateInventoryStmt = this.db.prepare(`
          UPDATE products 
          SET stockLevel = stockLevel + ?, updatedAt = ?
          WHERE id = ?
        `);
        updateInventoryStmt.run(item.quantity, now_iso, item.productId);
      }

      // Create audit log entry
      const auditId = this.uuid.v4();
      const auditStmt = this.db.prepare(`
        INSERT INTO audit_logs (
          id, userId, action, resource, resourceId, details, timestamp, createdAt
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `);

      auditStmt.run(
        auditId,
        voidData.cashierId,
        "void",
        "transactions",
        voidData.transactionId,
        JSON.stringify({
          reason: voidData.reason,
          managerApproval: voidData.managerApprovalId,
          originalAmount: originalTransaction.total,
        }),
        now_iso,
        now_iso
      );

      console.log("Database: Void transaction completed successfully");
      return {
        success: true,
        message: "Transaction voided successfully",
      };
    } catch (error) {
      console.error("Database: Void transaction failed:", error);
      return {
        success: false,
        message:
          error instanceof Error ? error.message : "Failed to void transaction",
      };
    }
  }

  /**
   * Void transaction (Drizzle)
   * Complex operation with validation, inventory restoration, and audit logging
   * NEW method - replaces voidTransaction()
   */
  async voidTransactionDrizzle(voidData: {
    transactionId: string;
    cashierId: string;
    reason: string;
    managerApprovalId?: string;
  }): Promise<{
    success: boolean;
    message: string;
  }> {
    const db = this.getDrizzleInstance();

    try {
      console.log(
        "Database: Starting void transaction for ID:",
        voidData.transactionId
      );

      // Get original transaction
      const originalTransaction = await this.getTransactionByIdDrizzle(
        voidData.transactionId
      );
      console.log("Database: Original transaction:", originalTransaction);

      if (!originalTransaction) {
        throw new Error("Transaction not found");
      }

      // Check if transaction can be voided
      if (originalTransaction.status !== "completed") {
        console.log(
          "Database: Transaction status is not completed:",
          originalTransaction.status
        );
        throw new Error("Only completed transactions can be voided");
      }

      // Check time window (30 minutes for void)
      const transactionTime = new Date(originalTransaction.timestamp);
      const now = new Date();
      const timeDifferenceMinutes =
        (now.getTime() - transactionTime.getTime()) / (1000 * 60);

      console.log(
        "Database: Time difference in minutes:",
        timeDifferenceMinutes
      );

      if (timeDifferenceMinutes > 30 && !voidData.managerApprovalId) {
        throw new Error(
          "Transaction is older than 30 minutes and requires manager approval"
        );
      }

      const now_iso = new Date().toISOString();

      // Use Drizzle transaction for atomicity
      db.transaction((tx) => {
        // 1. Update transaction status to voided
        console.log("Database: Updating transaction status to voided");
        tx.update(schema.transactions)
          .set({
            status: "voided",
            voidReason: voidData.reason,
          })
          .where(eq(schema.transactions.id, voidData.transactionId))
          .run();

        // 2. Restore inventory for all items in the transaction
        console.log(
          "Database: Restoring inventory for",
          originalTransaction.items.length,
          "items"
        );
        for (const item of originalTransaction.items) {
          const currentProduct = tx
            .select({ stockLevel: schema.products.stockLevel })
            .from(schema.products)
            .where(eq(schema.products.id, item.productId))
            .get();

          tx.update(schema.products)
            .set({
              stockLevel: (currentProduct?.stockLevel ?? 0) + item.quantity,
              updatedAt: now_iso,
            })
            .where(eq(schema.products.id, item.productId))
            .run();
        }

        // 3. Create audit log entry
        const auditId = this.uuid.v4();
        tx.insert(schema.auditLogs)
          .values({
            id: auditId,
            userId: voidData.cashierId,
            action: "void",
            resource: "transactions",
            resourceId: voidData.transactionId,
            details: JSON.stringify({
              reason: voidData.reason,
              managerApproval: voidData.managerApprovalId,
              originalAmount: originalTransaction.total,
            }),
            timestamp: now_iso,
            createdAt: now_iso,
          })
          .run();
      });

      console.log("Database: Void transaction completed successfully");
      return {
        success: true,
        message: "Transaction voided successfully",
      };
    } catch (error) {
      console.error("Database: Void transaction failed:", error);
      return {
        success: false,
        message:
          error instanceof Error ? error.message : "Failed to void transaction",
      };
    }
  }

  // Refund Transaction Methods - Delegate to TransactionManager
  async getTransactionById(transactionId: string): Promise<Transaction | null> {
    return this.transactions.getTransactionById(transactionId);
  }

  async getTransactionByIdAnyStatus(
    transactionId: string
  ): Promise<Transaction | null> {
    return this.transactions.getTransactionByIdAnyStatus(transactionId);
  }

  async getTransactionByReceiptNumber(
    receiptNumber: string
  ): Promise<Transaction | null> {
    return this.transactions.getTransactionByReceiptNumber(receiptNumber);
  }

  async getTransactionByReceiptNumberAnyStatus(
    receiptNumber: string
  ): Promise<Transaction | null> {
    return this.transactions.getTransactionByReceiptNumberAnyStatus(
      receiptNumber
    );
  }

  async getRecentTransactions(
    businessId: string,
    limit: number = 50
  ): Promise<Transaction[]> {
    return this.transactions.getRecentTransactions(businessId, limit);
  }

  async getShiftTransactions(
    shiftId: string,
    limit: number = 50
  ): Promise<Transaction[]> {
    return this.transactions.getShiftTransactions(shiftId, limit);
  }

  // ============================================
  // DRIZZLE ORM TRANSACTION METHODS
  // ============================================

  /**
   * Get transaction by ID using Drizzle ORM (type-safe)
   * Alternative to getTransactionById() above
   */
  async getTransactionByIdDrizzle(
    transactionId: string
  ): Promise<Transaction | null> {
    const drizzle = this.getDrizzleInstance();

    const [transaction] = await drizzle
      .select()
      .from(schema.transactions)
      .where(
        and(
          eq(schema.transactions.id, transactionId),
          eq(schema.transactions.status, "completed")
        )
      )
      .limit(1);

    if (!transaction) return null;

    // Get items separately (raw SQL for now as items need complex handling)
    const items = await this.getTransactionItems(transaction.id);

    return {
      ...transaction,
      items,
      appliedDiscounts: transaction.appliedDiscounts
        ? JSON.parse(transaction.appliedDiscounts)
        : undefined,
    } as Transaction;
  }

  /**
   * Get recent transactions using Drizzle ORM (type-safe)
   * Alternative to getRecentTransactions() above
   */
  async getRecentTransactionsDrizzle(
    businessId: string,
    limit: number = 50
  ): Promise<Transaction[]> {
    const drizzle = this.getDrizzleInstance();

    const transactions = await drizzle
      .select()
      .from(schema.transactions)
      .where(
        and(
          eq(schema.transactions.businessId, businessId),
          eq(schema.transactions.status, "completed")
        )
      )
      .orderBy(desc(schema.transactions.timestamp))
      .limit(limit);

    // Get items for each transaction
    const transactionsWithItems = await Promise.all(
      transactions.map(async (transaction) => ({
        ...transaction,
        items: await this.getTransactionItems(transaction.id),
        appliedDiscounts: transaction.appliedDiscounts
          ? JSON.parse(transaction.appliedDiscounts)
          : undefined,
      }))
    );

    return transactionsWithItems as Transaction[];
  }

  /**
   * Get transactions by shift using Drizzle ORM (type-safe)
   * Alternative to getShiftTransactions() above
   */
  async getShiftTransactionsDrizzle(
    shiftId: string,
    limit: number = 50
  ): Promise<Transaction[]> {
    const drizzle = this.getDrizzleInstance();

    const transactions = await drizzle
      .select()
      .from(schema.transactions)
      .where(
        and(
          eq(schema.transactions.shiftId, shiftId),
          eq(schema.transactions.status, "completed")
        )
      )
      .orderBy(desc(schema.transactions.timestamp))
      .limit(limit);

    // Get items for each transaction
    const transactionsWithItems = await Promise.all(
      transactions.map(async (transaction) => ({
        ...transaction,
        items: await this.getTransactionItems(transaction.id),
        appliedDiscounts: transaction.appliedDiscounts
          ? JSON.parse(transaction.appliedDiscounts)
          : undefined,
      }))
    );

    return transactionsWithItems as Transaction[];
  }

  /**
   * Get transaction statistics using Drizzle ORM (type-safe)
   * NEW method - demonstrates aggregation
   */
  async getTransactionStatsDrizzle(businessId: string, shiftId?: string) {
    const drizzle = this.getDrizzleInstance();

    const conditions = [
      eq(schema.transactions.businessId, businessId),
      eq(schema.transactions.status, "completed"),
    ];

    if (shiftId) {
      conditions.push(eq(schema.transactions.shiftId, shiftId));
    }

    const result = await drizzle
      .select({
        totalSales: drizzleSql<number>`COALESCE(SUM(${schema.transactions.total}), 0)`,
        totalTransactions: drizzleSql<number>`COUNT(*)`,
        averageTransaction: drizzleSql<number>`COALESCE(AVG(${schema.transactions.total}), 0)`,
        cashTotal: drizzleSql<number>`COALESCE(SUM(CASE WHEN ${schema.transactions.paymentMethod} = 'cash' THEN ${schema.transactions.total} ELSE 0 END), 0)`,
        cardTotal: drizzleSql<number>`COALESCE(SUM(CASE WHEN ${schema.transactions.paymentMethod} = 'card' THEN ${schema.transactions.total} ELSE 0 END), 0)`,
      })
      .from(schema.transactions)
      .where(and(...conditions));

    return (
      result[0] || {
        totalSales: 0,
        totalTransactions: 0,
        averageTransaction: 0,
        cashTotal: 0,
        cardTotal: 0,
      }
    );
  }

  /**
   * Search transactions by receipt number or customer using Drizzle ORM
   * NEW method - transaction search
   */
  async searchTransactionsDrizzle(
    businessId: string,
    searchTerm: string,
    limit: number = 20
  ): Promise<Transaction[]> {
    const drizzle = this.getDrizzleInstance();
    const searchPattern = `%${searchTerm}%`;

    const transactions = await drizzle
      .select()
      .from(schema.transactions)
      .where(
        and(
          eq(schema.transactions.businessId, businessId),
          eq(schema.transactions.status, "completed"),
          drizzleSql`${schema.transactions.receiptNumber} LIKE ${searchPattern}`
        )
      )
      .orderBy(desc(schema.transactions.timestamp))
      .limit(limit);

    const transactionsWithItems = await Promise.all(
      transactions.map(async (transaction) => ({
        ...transaction,
        items: await this.getTransactionItems(transaction.id),
        appliedDiscounts: transaction.appliedDiscounts
          ? JSON.parse(transaction.appliedDiscounts)
          : undefined,
      }))
    );

    return transactionsWithItems as Transaction[];
  }

  /**
   * Get transaction by receipt number (Drizzle)
   * NEW method - receipt lookup
   */
  async getTransactionByReceiptNumberDrizzle(
    receiptNumber: string
  ): Promise<Transaction | null> {
    const db = this.getDrizzleInstance();

    const transaction = db
      .select()
      .from(schema.transactions)
      .where(
        and(
          eq(schema.transactions.receiptNumber, receiptNumber),
          eq(schema.transactions.status, "completed")
        )
      )
      .orderBy(desc(schema.transactions.timestamp))
      .limit(1)
      .get();

    if (!transaction) return null;

    return {
      ...transaction,
      items: await this.getTransactionItems(transaction.id),
      appliedDiscounts: transaction.appliedDiscounts
        ? JSON.parse(transaction.appliedDiscounts)
        : undefined,
    } as Transaction;
  }

  /**
   * Get transaction by receipt number (any status) - Drizzle
   * NEW method - receipt lookup for voids
   */
  async getTransactionByReceiptNumberAnyStatusDrizzle(
    receiptNumber: string
  ): Promise<Transaction | null> {
    const db = this.getDrizzleInstance();

    const transaction = db
      .select()
      .from(schema.transactions)
      .where(eq(schema.transactions.receiptNumber, receiptNumber))
      .orderBy(desc(schema.transactions.timestamp))
      .limit(1)
      .get();

    if (!transaction) return null;

    return {
      ...transaction,
      items: await this.getTransactionItems(transaction.id),
      appliedDiscounts: transaction.appliedDiscounts
        ? JSON.parse(transaction.appliedDiscounts)
        : undefined,
    } as Transaction;
  }

  /**
   * Get transaction items with modifiers (Drizzle)
   * NEW method - detailed transaction items query
   */
  getTransactionItemsDrizzle(transactionId: string): TransactionItem[] {
    const db = this.getDrizzleInstance();

    const items = db
      .select()
      .from(schema.transactionItems)
      .where(eq(schema.transactionItems.transactionId, transactionId))
      .all();

    // Get applied modifiers for each item
    return items.map((item) => {
      const modifiers = db
        .select()
        .from(schema.appliedModifiers)
        .where(eq(schema.appliedModifiers.transactionItemId, item.id))
        .all();

      return {
        ...item,
        refundedQuantity: item.refundedQuantity ?? undefined,
        weight: item.weight ?? undefined,
        discountAmount: item.discountAmount ?? undefined,
        appliedDiscounts: item.appliedDiscounts
          ? JSON.parse(item.appliedDiscounts)
          : undefined,
        appliedModifiers: modifiers as AppliedModifier[],
      };
    });
  }

  /**
   * Create transaction with items and modifiers (Drizzle)
   * Complex operation with atomic transaction support
   * NEW method - replaces createTransaction()
   */
  createTransactionDrizzle(
    transaction: Omit<Transaction, "id" | "createdAt">
  ): Transaction {
    const db = this.getDrizzleInstance();
    const id = this.uuid.v4();
    const now = new Date().toISOString();

    // Use Drizzle transaction for atomicity
    const result = db.transaction((tx) => {
      // 1. Insert main transaction
      tx.insert(schema.transactions)
        .values({
          id,
          shiftId: transaction.shiftId,
          businessId: transaction.businessId,
          type: transaction.type,
          subtotal: transaction.subtotal,
          tax: transaction.tax,
          total: transaction.total,
          paymentMethod: transaction.paymentMethod,
          cashAmount: transaction.cashAmount ?? null,
          cardAmount: transaction.cardAmount ?? null,
          status: transaction.status,
          voidReason: transaction.voidReason ?? null,
          customerId: transaction.customerId ?? null,
          receiptNumber: transaction.receiptNumber,
          appliedDiscounts: transaction.appliedDiscounts
            ? JSON.stringify(transaction.appliedDiscounts)
            : null,
          timestamp: transaction.timestamp,
          createdAt: now,
        })
        .run();

      // 2. Insert transaction items
      if (transaction.items && transaction.items.length > 0) {
        for (const item of transaction.items) {
          const itemId = this.uuid.v4();

          tx.insert(schema.transactionItems)
            .values({
              id: itemId,
              transactionId: id,
              productId: item.productId,
              productName: item.productName,
              quantity: item.quantity,
              unitPrice: item.unitPrice,
              totalPrice: item.totalPrice,
              refundedQuantity: item.refundedQuantity ?? null,
              weight: item.weight ?? null,
              discountAmount: item.discountAmount ?? null,
              appliedDiscounts: item.appliedDiscounts
                ? JSON.stringify(item.appliedDiscounts)
                : null,
              createdAt: now,
            })
            .run();

          // 3. Insert applied modifiers for each item
          if (item.appliedModifiers && item.appliedModifiers.length > 0) {
            for (const modifier of item.appliedModifiers) {
              const modifierId = this.uuid.v4();

              tx.insert(schema.appliedModifiers)
                .values({
                  id: modifierId,
                  transactionItemId: itemId,
                  modifierId: modifier.modifierId,
                  modifierName: modifier.modifierName,
                  optionId: modifier.optionId,
                  optionName: modifier.optionName,
                  price: modifier.price,
                  createdAt: now,
                })
                .run();
            }
          }
        }
      }

      return {
        ...transaction,
        id,
        createdAt: now,
      };
    });

    return result;
  }

  /**
   * Create transaction item (Drizzle)
   * Helper method for individual item creation
   * NEW method - replaces createTransactionItem()
   */
  createTransactionItemDrizzle(
    transactionId: string,
    item: Omit<TransactionItem, "id" | "createdAt">
  ): string {
    const db = this.getDrizzleInstance();
    const itemId = this.uuid.v4();
    const now = new Date().toISOString();

    db.transaction((tx) => {
      // Insert transaction item
      tx.insert(schema.transactionItems)
        .values({
          id: itemId,
          transactionId,
          productId: item.productId,
          productName: item.productName,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          totalPrice: item.totalPrice,
          refundedQuantity: item.refundedQuantity ?? null,
          weight: item.weight ?? null,
          discountAmount: item.discountAmount ?? null,
          appliedDiscounts: item.appliedDiscounts
            ? JSON.stringify(item.appliedDiscounts)
            : null,
          createdAt: now,
        })
        .run();

      // Insert applied modifiers if any
      if (item.appliedModifiers && item.appliedModifiers.length > 0) {
        for (const modifier of item.appliedModifiers) {
          const modifierId = this.uuid.v4();

          tx.insert(schema.appliedModifiers)
            .values({
              id: modifierId,
              transactionItemId: itemId,
              modifierId: modifier.modifierId,
              modifierName: modifier.modifierName,
              optionId: modifier.optionId,
              optionName: modifier.optionName,
              price: modifier.price,
              createdAt: now,
            })
            .run();
        }
      }
    });

    return itemId;
  }

  /**
   * Create applied modifier (Drizzle)
   * Helper method for individual modifier creation
   * NEW method - replaces createAppliedModifier()
   */
  createAppliedModifierDrizzle(
    transactionItemId: string,
    modifier: Omit<AppliedModifier, "id" | "createdAt">
  ): void {
    const db = this.getDrizzleInstance();
    const id = this.uuid.v4();
    const now = new Date().toISOString();

    db.insert(schema.appliedModifiers)
      .values({
        id,
        transactionItemId,
        modifierId: modifier.modifierId,
        modifierName: modifier.modifierName,
        optionId: modifier.optionId,
        optionName: modifier.optionName,
        price: modifier.price,
        createdAt: now,
      })
      .run();
  }

  createRefundTransaction(refundData: {
    originalTransactionId: string;
    shiftId: string;
    businessId: string;
    refundItems: RefundItem[];
    refundReason: string;
    refundMethod: "original" | "store_credit" | "cash" | "card";
    managerApprovalId?: string;
    cashierId: string;
  }): Promise<Transaction> {
    return (async () => {
      // Get original transaction to validate refund
      const originalTransaction = await this.getTransactionById(
        refundData.originalTransactionId
      );
      if (!originalTransaction) {
        throw new Error("Original transaction not found");
      }

      // Calculate refund totals
      const refundSubtotal = refundData.refundItems.reduce(
        (sum, item) => sum + item.refundAmount,
        0
      );
      const refundTax =
        refundSubtotal *
        (originalTransaction.tax / originalTransaction.subtotal); // Proportional tax
      const refundTotal = refundSubtotal + refundTax;

      // Create refund transaction
      const refundId = this.uuid.v4();
      const receiptNumber = `REF-${Date.now()}`;
      const now = new Date().toISOString();

      // Determine payment method for refund
      let paymentMethod: "cash" | "card" | "mixed";
      if (refundData.refundMethod === "original") {
        paymentMethod = originalTransaction.paymentMethod;
      } else if (refundData.refundMethod === "cash") {
        paymentMethod = "cash";
      } else if (refundData.refundMethod === "card") {
        paymentMethod = "card";
      } else {
        // For store credit, we'll treat it as cash for now
        paymentMethod = "cash";
      }

      const refundTransaction = this.db.transaction(() => {
        // Create the refund transaction record
        const transactionStmt = this.db.prepare(`
        INSERT INTO transactions (
          id, shiftId, businessId, type, subtotal, tax, total, 
          paymentMethod, cashAmount, cardAmount, status, 
          receiptNumber, timestamp, createdAt, originalTransactionId,
          refundReason, refundMethod, managerApprovalId, isPartialRefund
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);

        const isPartialRefund =
          refundData.refundItems.length < originalTransaction.items.length ||
          refundData.refundItems.some((refundItem) => {
            const originalItem = originalTransaction.items.find(
              (item) => item.id === refundItem.originalItemId
            );
            return (
              originalItem && refundItem.refundQuantity < originalItem.quantity
            );
          });

        transactionStmt.run(
          refundId,
          refundData.shiftId,
          refundData.businessId,
          "refund",
          -refundSubtotal, // Negative for refund
          -refundTax,
          -refundTotal,
          paymentMethod,
          paymentMethod === "cash" ? -refundTotal : null,
          paymentMethod === "card" ? -refundTotal : null,
          "completed",
          receiptNumber,
          now,
          now,
          refundData.originalTransactionId,
          refundData.refundReason,
          refundData.refundMethod,
          refundData.managerApprovalId || null,
          isPartialRefund ? 1 : 0
        );

        // Create refund transaction items
        for (const refundItem of refundData.refundItems) {
          const itemId = this.uuid.v4();
          const itemStmt = this.db.prepare(`
          INSERT INTO transaction_items (
            id, transactionId, productId, productName, quantity, 
            unitPrice, totalPrice, createdAt
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `);

          itemStmt.run(
            itemId,
            refundId,
            refundItem.productId,
            refundItem.productName,
            -refundItem.refundQuantity, // Negative for refund
            refundItem.unitPrice,
            -refundItem.refundAmount,
            now
          );

          // Update original item's refunded quantity
          const updateOriginalStmt = this.db.prepare(`
          UPDATE transaction_items 
          SET refundedQuantity = COALESCE(refundedQuantity, 0) + ?
          WHERE id = ?
        `);
          updateOriginalStmt.run(
            refundItem.refundQuantity,
            refundItem.originalItemId
          );

          // Update inventory if item is restockable
          if (refundItem.restockable) {
            const updateInventoryStmt = this.db.prepare(`
            UPDATE products 
            SET stockLevel = stockLevel + ?, updatedAt = ?
            WHERE id = ?
          `);
            updateInventoryStmt.run(
              refundItem.refundQuantity,
              now,
              refundItem.productId
            );
          }
        }

        return refundId;
      });

      refundTransaction();

      // Return the created refund transaction
      const result = await this.getTransactionById(refundId);
      if (!result) {
        throw new Error("Failed to retrieve refund transaction");
      }
      return result;
    })();
  }

  async validateRefundEligibility(
    transactionId: string,
    refundItems: RefundItem[]
  ): Promise<{
    isValid: boolean;
    errors: string[];
  }> {
    const errors: string[] = [];

    // Get original transaction
    const originalTransaction = await this.getTransactionById(transactionId);
    if (!originalTransaction) {
      errors.push("Original transaction not found");
      return { isValid: false, errors };
    }

    // Check if transaction is too old (configurable - 30 days)
    const transactionDate = new Date(originalTransaction.timestamp);
    const daysDiff =
      (Date.now() - transactionDate.getTime()) / (1000 * 60 * 60 * 24);
    if (daysDiff > 30) {
      errors.push("Transaction is older than 30 days and cannot be refunded");
    }

    // Validate each refund item
    for (const refundItem of refundItems) {
      const originalItem = originalTransaction.items.find(
        (item) => item.id === refundItem.originalItemId
      );
      if (!originalItem) {
        errors.push(
          `Item ${refundItem.productName} not found in original transaction`
        );
        continue;
      }

      // Check if refund quantity exceeds available quantity
      const availableQuantity =
        originalItem.quantity - (originalItem.refundedQuantity || 0);
      if (refundItem.refundQuantity > availableQuantity) {
        errors.push(
          `Cannot refund ${refundItem.refundQuantity} of ${refundItem.productName}. Only ${availableQuantity} available.`
        );
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }

  /**
   * Create refund transaction (Drizzle)
   * Complex operation with validation, proportional tax, and inventory restoration
   * NEW method - replaces createRefundTransaction()
   */
  async createRefundTransactionDrizzle(refundData: {
    originalTransactionId: string;
    shiftId: string;
    businessId: string;
    refundItems: RefundItem[];
    refundReason: string;
    refundMethod: "original" | "store_credit" | "cash" | "card";
    managerApprovalId?: string;
    cashierId: string;
  }): Promise<Transaction> {
    const db = this.getDrizzleInstance();

    // Get original transaction to validate refund
    const originalTransaction = await this.getTransactionByIdDrizzle(
      refundData.originalTransactionId
    );
    if (!originalTransaction) {
      throw new Error("Original transaction not found");
    }

    // Calculate refund totals
    const refundSubtotal = refundData.refundItems.reduce(
      (sum, item) => sum + item.refundAmount,
      0
    );
    const refundTax =
      refundSubtotal * (originalTransaction.tax / originalTransaction.subtotal);
    const refundTotal = refundSubtotal + refundTax;

    // Determine payment method for refund
    let paymentMethod: "cash" | "card" | "mixed";
    if (refundData.refundMethod === "original") {
      paymentMethod = originalTransaction.paymentMethod;
    } else if (refundData.refundMethod === "cash") {
      paymentMethod = "cash";
    } else if (refundData.refundMethod === "card") {
      paymentMethod = "card";
    } else {
      paymentMethod = "cash"; // Store credit treated as cash
    }

    const refundId = this.uuid.v4();
    const receiptNumber = `REF-${Date.now()}`;
    const now = new Date().toISOString();

    // Check if partial refund
    const isPartialRefund =
      refundData.refundItems.length < originalTransaction.items.length ||
      refundData.refundItems.some((refundItem) => {
        const originalItem = originalTransaction.items.find(
          (item) => item.id === refundItem.originalItemId
        );
        return (
          originalItem && refundItem.refundQuantity < originalItem.quantity
        );
      });

    // Use Drizzle transaction for atomicity
    db.transaction((tx) => {
      // 1. Create refund transaction record
      tx.insert(schema.transactions)
        .values({
          id: refundId,
          shiftId: refundData.shiftId,
          businessId: refundData.businessId,
          type: "refund",
          subtotal: -refundSubtotal, // Negative for refund
          tax: -refundTax,
          total: -refundTotal,
          paymentMethod,
          cashAmount: paymentMethod === "cash" ? -refundTotal : null,
          cardAmount: paymentMethod === "card" ? -refundTotal : null,
          status: "completed",
          receiptNumber,
          timestamp: now,
          createdAt: now,
          originalTransactionId: refundData.originalTransactionId,
          refundReason: refundData.refundReason,
          refundMethod: refundData.refundMethod,
          managerApprovalId: refundData.managerApprovalId ?? null,
          isPartialRefund: isPartialRefund,
          voidReason: null,
          customerId: null,
          appliedDiscounts: null,
        })
        .run();

      // 2. Create refund transaction items
      for (const refundItem of refundData.refundItems) {
        const itemId = this.uuid.v4();

        tx.insert(schema.transactionItems)
          .values({
            id: itemId,
            transactionId: refundId,
            productId: refundItem.productId,
            productName: refundItem.productName,
            quantity: -refundItem.refundQuantity, // Negative for refund
            unitPrice: refundItem.unitPrice,
            totalPrice: -refundItem.refundAmount,
            refundedQuantity: null,
            weight: null,
            discountAmount: null,
            appliedDiscounts: null,
            createdAt: now,
          })
          .run();

        // 3. Update original item's refunded quantity
        const currentRefunded = tx
          .select({
            refundedQuantity: schema.transactionItems.refundedQuantity,
          })
          .from(schema.transactionItems)
          .where(eq(schema.transactionItems.id, refundItem.originalItemId))
          .get();

        tx.update(schema.transactionItems)
          .set({
            refundedQuantity:
              (currentRefunded?.refundedQuantity ?? 0) +
              refundItem.refundQuantity,
          })
          .where(eq(schema.transactionItems.id, refundItem.originalItemId))
          .run();

        // 4. Update inventory if item is restockable
        if (refundItem.restockable) {
          const currentProduct = tx
            .select({ stockLevel: schema.products.stockLevel })
            .from(schema.products)
            .where(eq(schema.products.id, refundItem.productId))
            .get();

          tx.update(schema.products)
            .set({
              stockLevel:
                (currentProduct?.stockLevel ?? 0) + refundItem.refundQuantity,
              updatedAt: now,
            })
            .where(eq(schema.products.id, refundItem.productId))
            .run();
        }
      }
    });

    // Return the created refund transaction
    const createdTransaction = await this.getTransactionByIdDrizzle(refundId);
    if (!createdTransaction) {
      throw new Error("Failed to retrieve created refund transaction");
    }
    return createdTransaction;
  }

  async validateVoidEligibility(transactionId: string): Promise<{
    isValid: boolean;
    errors: string[];
    requiresManagerApproval: boolean;
  }> {
    const errors: string[] = [];
    let requiresManagerApproval = false;

    // Get transaction
    const transaction = await this.getTransactionByIdAnyStatus(transactionId);
    if (!transaction) {
      errors.push("Transaction not found");
      return { isValid: false, errors, requiresManagerApproval: false };
    }

    // Check if already voided or refunded
    if (transaction.status !== "completed") {
      errors.push("Transaction is not in completed status");
    }

    // Check time window (30 minutes for normal void)
    const transactionTime = new Date(transaction.timestamp);
    const now = new Date();
    const timeDifferenceMinutes =
      (now.getTime() - transactionTime.getTime()) / (1000 * 60);

    if (timeDifferenceMinutes > 30) {
      requiresManagerApproval = true;
    }

    // Check if payment method allows void (card payments might be settled)
    if (transaction.paymentMethod === "card" && timeDifferenceMinutes > 60) {
      errors.push(
        "Card payment may be settled - refund required instead of void"
      );
    }

    return {
      isValid: errors.length === 0,
      errors,
      requiresManagerApproval,
    };
  }

  // Cash Drawer Count Methods
  createCashDrawerCount(
    count: Omit<CashDrawerCount, "id" | "createdAt">
  ): CashDrawerCount {
    const id = this.uuid.v4();
    const now = new Date().toISOString();

    const stmt = this.db.prepare(`
      INSERT INTO cash_drawer_counts (
        id, shiftId, businessId, countType, expectedAmount, countedAmount, 
        variance, notes, countedBy, timestamp, createdAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    const variance = count.countedAmount - count.expectedAmount;

    stmt.run(
      id,
      count.shiftId,
      count.businessId,
      count.countType,
      count.expectedAmount,
      count.countedAmount,
      variance,
      count.notes || null,
      count.countedBy,
      count.timestamp,
      now
    );

    return {
      ...count,
      id,
      variance,
      createdAt: now,
    };
  }

  getCashDrawerCountsByShiftId(shiftId: string): CashDrawerCount[] {
    const stmt = this.db.prepare(`
      SELECT * FROM cash_drawer_counts WHERE shiftId = ? ORDER BY timestamp ASC
    `);
    return stmt.all(shiftId) as CashDrawerCount[];
  }

  // ============================================
  // DRIZZLE ORM CASH DRAWER METHODS
  // ============================================

  /**
   * Create cash drawer count (Drizzle)
   */
  createCashDrawerCountDrizzle(
    count: Omit<CashDrawerCount, "id" | "createdAt">
  ): CashDrawerCount {
    const db = this.getDrizzleInstance();
    const id = this.uuid.v4();
    const now = new Date().toISOString();
    const variance = count.countedAmount - count.expectedAmount;

    db.insert(schema.cashDrawerCounts)
      .values({
        id,
        shiftId: count.shiftId,
        businessId: count.businessId,
        countType: count.countType,
        expectedAmount: count.expectedAmount,
        countedAmount: count.countedAmount,
        variance,
        notes: count.notes ?? null,
        countedBy: count.countedBy,
        timestamp: count.timestamp,
        createdAt: now,
      })
      .run();

    return {
      ...count,
      id,
      variance,
      createdAt: now,
    };
  }

  /**
   * Get cash drawer counts by shift (Drizzle)
   */
  getCashDrawerCountsByShiftIdDrizzle(shiftId: string): CashDrawerCount[] {
    const db = this.getDrizzleInstance();

    const result = db
      .select()
      .from(schema.cashDrawerCounts)
      .where(eq(schema.cashDrawerCounts.shiftId, shiftId))
      .orderBy(asc(schema.cashDrawerCounts.timestamp))
      .all();

    return result.map((c) => ({
      ...c,
      notes: c.notes ?? undefined,
    }));
  }

  /**
   * Get latest cash drawer count for shift (Drizzle)
   * NEW method - get most recent count
   */
  getLatestCashDrawerCountDrizzle(shiftId: string): CashDrawerCount | null {
    const db = this.getDrizzleInstance();

    const result = db
      .select()
      .from(schema.cashDrawerCounts)
      .where(eq(schema.cashDrawerCounts.shiftId, shiftId))
      .orderBy(desc(schema.cashDrawerCounts.timestamp))
      .limit(1)
      .get();

    if (!result) return null;

    return {
      ...result,
      notes: result.notes ?? undefined,
    };
  }

  // Get current cash drawer balance based on latest count or estimated amount
  getCurrentCashDrawerBalance(shiftId: string): {
    amount: number;
    isEstimated: boolean;
    lastCountTime?: string;
    variance?: number;
  } {
    // Get shift details
    const shiftStmt = this.db.prepare(`SELECT * FROM shifts WHERE id = ?`);
    const shift = shiftStmt.get(shiftId) as Shift | null;

    if (!shift) {
      return { amount: 0, isEstimated: true };
    }

    // Get the most recent cash count
    const countStmt = this.db.prepare(`
      SELECT * FROM cash_drawer_counts 
      WHERE shiftId = ? 
      ORDER BY timestamp DESC 
      LIMIT 1
    `);
    const latestCount = countStmt.get(shiftId) as CashDrawerCount | null;

    if (latestCount) {
      // Use actual counted amount
      const expectedAtCountTime = this.getExpectedCashForShift(shiftId);
      const variance =
        latestCount.countedAmount - expectedAtCountTime.expectedAmount;

      return {
        amount: latestCount.countedAmount,
        isEstimated: false,
        lastCountTime: latestCount.timestamp,
        variance: variance,
      };
    } else {
      // Estimate based on starting cash + sales
      const expectedCash = this.getExpectedCashForShift(shiftId);
      return {
        amount: expectedCash.expectedAmount,
        isEstimated: true,
      };
    }
  }

  // Calculate expected cash amount for a shift
  getExpectedCashForShift(shiftId: string): {
    expectedAmount: number;
    breakdown: {
      startingCash: number;
      cashSales: number;
      cashRefunds: number;
      cashVoids: number;
    };
  } {
    // Get shift details
    const shift = this.db
      .prepare("SELECT * FROM shifts WHERE id = ?")
      .get(shiftId) as Shift | null;

    if (!shift) {
      throw new Error("Shift not found");
    }

    // Calculate cash transactions for this shift
    const cashTransactions = this.db
      .prepare(
        `
        SELECT 
          type,
          SUM(CASE 
            WHEN paymentMethod = 'cash' THEN total 
            WHEN paymentMethod = 'mixed' THEN COALESCE(cashAmount, 0)
            ELSE 0 
          END) as cashAmount
        FROM transactions 
        WHERE shiftId = ? AND status = 'completed' 
          AND (paymentMethod = 'cash' OR (paymentMethod = 'mixed' AND cashAmount > 0))
        GROUP BY type
      `
      )
      .all(shiftId) as Array<{ type: string; cashAmount: number }>;

    let cashSales = 0;
    let cashRefunds = 0;
    let cashVoids = 0;

    cashTransactions.forEach((transaction) => {
      switch (transaction.type) {
        case "sale":
          cashSales += transaction.cashAmount;
          break;
        case "refund":
          cashRefunds += Math.abs(transaction.cashAmount); // Refunds are negative, so we take absolute value
          break;
        case "void":
          cashVoids += Math.abs(transaction.cashAmount); // Voids are negative, so we take absolute value
          break;
      }
    });

    const expectedAmount =
      shift.startingCash + cashSales - cashRefunds - cashVoids;

    return {
      expectedAmount,
      breakdown: {
        startingCash: shift.startingCash,
        cashSales,
        cashRefunds,
        cashVoids,
      },
    };
  }

  /**
   * Get current cash drawer balance (Drizzle)
   * NEW method - replaces getCurrentCashDrawerBalance()
   */
  getCurrentCashDrawerBalanceDrizzle(shiftId: string): {
    amount: number;
    isEstimated: boolean;
    lastCountTime?: string;
    variance?: number;
  } {
    const db = this.getDrizzleInstance();

    // Get shift details
    const shift = db
      .select()
      .from(schema.shifts)
      .where(eq(schema.shifts.id, shiftId))
      .get();

    if (!shift) {
      return { amount: 0, isEstimated: true };
    }

    // Get the most recent cash count
    const latestCount = this.getLatestCashDrawerCountDrizzle(shiftId);

    if (latestCount) {
      // Use actual counted amount
      const expectedAtCountTime = this.getExpectedCashForShiftDrizzle(shiftId);
      const variance =
        latestCount.countedAmount - expectedAtCountTime.expectedAmount;

      return {
        amount: latestCount.countedAmount,
        isEstimated: false,
        lastCountTime: latestCount.timestamp,
        variance: variance,
      };
    } else {
      // Estimate based on starting cash + sales
      const expectedCash = this.getExpectedCashForShiftDrizzle(shiftId);
      return {
        amount: expectedCash.expectedAmount,
        isEstimated: true,
      };
    }
  }

  /**
   * Calculate expected cash amount for a shift (Drizzle)
   * Complex aggregation query
   * NEW method - replaces getExpectedCashForShift()
   */
  getExpectedCashForShiftDrizzle(shiftId: string): {
    expectedAmount: number;
    breakdown: {
      startingCash: number;
      cashSales: number;
      cashRefunds: number;
      cashVoids: number;
    };
  } {
    const db = this.getDrizzleInstance();

    // Get shift details
    const shift = db
      .select()
      .from(schema.shifts)
      .where(eq(schema.shifts.id, shiftId))
      .get();

    if (!shift) {
      throw new Error("Shift not found");
    }

    // Calculate cash transactions using aggregation
    const cashTransactions = db
      .select({
        type: schema.transactions.type,
        cashAmount: drizzleSql<number>`SUM(CASE 
          WHEN ${schema.transactions.paymentMethod} = 'cash' THEN ${schema.transactions.total}
          WHEN ${schema.transactions.paymentMethod} = 'mixed' THEN COALESCE(${schema.transactions.cashAmount}, 0)
          ELSE 0
        END)`,
      })
      .from(schema.transactions)
      .where(
        and(
          eq(schema.transactions.shiftId, shiftId),
          eq(schema.transactions.status, "completed"),
          drizzleSql`(${schema.transactions.paymentMethod} = 'cash' OR (${schema.transactions.paymentMethod} = 'mixed' AND ${schema.transactions.cashAmount} > 0))`
        )
      )
      .groupBy(schema.transactions.type)
      .all();

    let cashSales = 0;
    let cashRefunds = 0;
    let cashVoids = 0;

    cashTransactions.forEach((transaction) => {
      switch (transaction.type) {
        case "sale":
          cashSales += transaction.cashAmount;
          break;
        case "refund":
          cashRefunds += Math.abs(transaction.cashAmount);
          break;
        case "void":
          cashVoids += Math.abs(transaction.cashAmount);
          break;
      }
    });

    const expectedAmount =
      shift.startingCash + cashSales - cashRefunds - cashVoids;

    return {
      expectedAmount,
      breakdown: {
        startingCash: shift.startingCash,
        cashSales,
        cashRefunds,
        cashVoids,
      },
    };
  }

  // Audit logging method
  createAuditLog(auditData: {
    userId: string;
    action: string;
    resource: string;
    resourceId: string;
    details?: any;
  }): void {
    const auditId = this.uuid.v4();
    const now = new Date().toISOString();

    this.db
      .prepare(
        `
        INSERT INTO audit_logs (
          id, userId, action, resource, resourceId, details, timestamp, createdAt
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `
      )
      .run(
        auditId,
        auditData.userId,
        auditData.action,
        auditData.resource,
        auditData.resourceId,
        auditData.details ? JSON.stringify(auditData.details) : null,
        now,
        now
      );
  }

  // ============================================
  // DRIZZLE ORM AUDIT LOG METHODS
  // ============================================

  /**
   * Create audit log (Drizzle)
   */
  createAuditLogDrizzle(auditData: {
    userId: string;
    action: string;
    resource: string;
    resourceId: string;
    details?: any;
  }): void {
    const db = this.getDrizzleInstance();
    const auditId = this.uuid.v4();
    const now = new Date().toISOString();

    db.insert(schema.auditLogs)
      .values({
        id: auditId,
        userId: auditData.userId,
        action: auditData.action,
        resource: auditData.resource,
        resourceId: auditData.resourceId,
        details: auditData.details ? JSON.stringify(auditData.details) : null,
        timestamp: now,
        createdAt: now,
      })
      .run();
  }

  /**
   * Get audit logs with filtering (Drizzle)
   * NEW method - query audit trail
   */
  getAuditLogsDrizzle(options?: {
    userId?: string;
    resource?: string;
    resourceId?: string;
    action?: string;
    limit?: number;
    offset?: number;
  }): any[] {
    const db = this.getDrizzleInstance();

    let query = db.select().from(schema.auditLogs);

    // Build where conditions
    const conditions = [];
    if (options?.userId) {
      conditions.push(eq(schema.auditLogs.userId, options.userId));
    }
    if (options?.resource) {
      conditions.push(eq(schema.auditLogs.resource, options.resource));
    }
    if (options?.resourceId) {
      conditions.push(eq(schema.auditLogs.resourceId, options.resourceId));
    }
    if (options?.action) {
      conditions.push(eq(schema.auditLogs.action, options.action));
    }

    if (conditions.length > 0) {
      query = query.where(and(...conditions)) as any;
    }

    query = query.orderBy(desc(schema.auditLogs.timestamp)) as any;

    if (options?.limit) {
      query = query.limit(options.limit) as any;
    }
    if (options?.offset) {
      query = query.offset(options.offset) as any;
    }

    return query.all();
  }

  /**
   * Get audit logs by entity (Drizzle)
   * NEW method - track entity history
   */
  getAuditLogsByEntityDrizzle(resource: string, resourceId: string): any[] {
    const db = this.getDrizzleInstance();

    return db
      .select()
      .from(schema.auditLogs)
      .where(
        and(
          eq(schema.auditLogs.resource, resource),
          eq(schema.auditLogs.resourceId, resourceId)
        )
      )
      .orderBy(desc(schema.auditLogs.timestamp))
      .all();
  }

  // ============================================
  // DRIZZLE ORM REPORTING METHODS
  // ============================================

  /**
   * Generate shift report (Drizzle)
   * Complex reporting with aggregations and calculations
   * NEW method - replaces generateShiftReport()
   */
  async generateShiftReportDrizzle(
    shiftId: string
  ): Promise<ShiftReport | null> {
    const db = this.getDrizzleInstance();

    // Get shift data
    const shift = this.shifts.getShiftById(shiftId);
    if (!shift) return null;

    // Get linked schedule if exists
    let schedule: Schedule | undefined;
    if (shift.scheduleId) {
      const scheduleResult = db
        .select()
        .from(schema.schedules)
        .where(eq(schema.schedules.id, shift.scheduleId))
        .get();

      if (scheduleResult) {
        schedule = {
          ...scheduleResult,
          assignedRegister: scheduleResult.assignedRegister ?? undefined,
          notes: scheduleResult.notes ?? undefined,
        };
      }
    }

    // Get transactions using existing Drizzle method
    const allTransactions = db
      .select()
      .from(schema.transactions)
      .where(eq(schema.transactions.shiftId, shiftId))
      .orderBy(desc(schema.transactions.timestamp))
      .all();

    // Transform transactions with items
    const transactions = allTransactions.map((t) => ({
      ...t,
      items: this.getTransactionItemsDrizzle(t.id),
      appliedDiscounts: t.appliedDiscounts
        ? JSON.parse(t.appliedDiscounts)
        : undefined,
    })) as Transaction[];

    // Get cash drawer counts
    const cashDrawerCounts = this.getCashDrawerCountsByShiftIdDrizzle(shiftId);

    // Calculate totals using aggregation
    const salesStats = db
      .select({
        totalSales: drizzleSql<number>`COALESCE(SUM(CASE WHEN ${schema.transactions.type} = 'sale' AND ${schema.transactions.status} = 'completed' THEN ${schema.transactions.total} ELSE 0 END), 0)`,
        totalRefunds: drizzleSql<number>`COALESCE(ABS(SUM(CASE WHEN ${schema.transactions.type} = 'refund' AND ${schema.transactions.status} = 'completed' THEN ${schema.transactions.total} ELSE 0 END)), 0)`,
        totalVoids: drizzleSql<number>`COALESCE(SUM(CASE WHEN ${schema.transactions.status} = 'voided' THEN ${schema.transactions.total} ELSE 0 END), 0)`,
      })
      .from(schema.transactions)
      .where(eq(schema.transactions.shiftId, shiftId))
      .get();

    const totalSales = salesStats?.totalSales ?? 0;
    const totalRefunds = salesStats?.totalRefunds ?? 0;
    const totalVoids = salesStats?.totalVoids ?? 0;
    const cashVariance = shift.cashVariance ?? 0;

    // Calculate attendance variance if schedule exists
    let attendanceVariance;
    if (schedule) {
      const plannedStart = new Date(schedule.startTime);
      const actualStart = new Date(shift.startTime);
      const plannedEnd = schedule.endTime ? new Date(schedule.endTime) : null;
      const actualEnd = shift.endTime ? new Date(shift.endTime) : null;

      const earlyMinutes = Math.max(
        0,
        (plannedStart.getTime() - actualStart.getTime()) / (1000 * 60)
      );
      const lateMinutes = Math.max(
        0,
        (actualStart.getTime() - plannedStart.getTime()) / (1000 * 60)
      );

      attendanceVariance = {
        plannedStart: schedule.startTime,
        actualStart: shift.startTime,
        plannedEnd: schedule.endTime,
        actualEnd: shift.endTime,
        earlyMinutes: earlyMinutes > 0 ? Math.round(earlyMinutes) : undefined,
        lateMinutes: lateMinutes > 0 ? Math.round(lateMinutes) : undefined,
      };
    }

    return {
      shift,
      schedule,
      transactions,
      cashDrawerCounts,
      totalSales,
      totalRefunds,
      totalVoids,
      cashVariance,
      attendanceVariance,
    };
  }

  // Reporting Methods
  async generateShiftReport(shiftId: string): Promise<ShiftReport | null> {
    // Get shift data
    const shiftStmt = this.db.prepare(`SELECT * FROM shifts WHERE id = ?`);
    const shift = shiftStmt.get(shiftId) as Shift;

    if (!shift) return null;

    // Get linked schedule if exists
    let schedule: Schedule | undefined;
    if (shift.scheduleId) {
      const scheduleStmt = this.db.prepare(
        `SELECT * FROM schedules WHERE id = ?`
      );
      schedule = scheduleStmt.get(shift.scheduleId) as Schedule;
    }

    // Get transactions
    const transactions = await this.getTransactionsByShiftId(shiftId);

    // Get cash drawer counts
    const cashDrawerCounts = this.getCashDrawerCountsByShiftId(shiftId);

    // Calculate totals
    const totalSales = transactions
      .filter((t) => t.type === "sale" && t.status === "completed")
      .reduce((sum, t) => sum + t.total, 0);

    const totalRefunds = Math.abs(
      transactions
        .filter((t) => t.type === "refund" && t.status === "completed")
        .reduce((sum, t) => sum + t.total, 0)
    );

    const totalVoids = transactions
      .filter((t) => t.status === "voided")
      .reduce((sum, t) => sum + t.total, 0);

    const cashVariance = shift.cashVariance || 0;

    // Calculate attendance variance if schedule exists
    let attendanceVariance;
    if (schedule) {
      const plannedStart = new Date(schedule.startTime);
      const actualStart = new Date(shift.startTime);
      const plannedEnd = schedule.endTime ? new Date(schedule.endTime) : null;
      const actualEnd = shift.endTime ? new Date(shift.endTime) : null;

      const earlyMinutes = Math.max(
        0,
        (plannedStart.getTime() - actualStart.getTime()) / (1000 * 60)
      );
      const lateMinutes = Math.max(
        0,
        (actualStart.getTime() - plannedStart.getTime()) / (1000 * 60)
      );

      attendanceVariance = {
        plannedStart: schedule.startTime,
        actualStart: shift.startTime,
        plannedEnd: schedule.endTime,
        actualEnd: shift.endTime,
        earlyMinutes: earlyMinutes > 0 ? Math.round(earlyMinutes) : undefined,
        lateMinutes: lateMinutes > 0 ? Math.round(lateMinutes) : undefined,
      };
    }

    return {
      shift,
      schedule,
      transactions,
      cashDrawerCounts,
      totalSales,
      totalRefunds,
      totalVoids,
      cashVariance,
      attendanceVariance,
    };
  }

  // Method to empty all tables in the database
  async emptyAllTables(): Promise<{
    success: boolean;
    tablesEmptied: string[];
    rowsDeleted: number;
    error?: string;
  }> {
    try {
      const tablesEmptied: string[] = [];
      let totalRowsDeleted = 0;

      // Get list of all tables (excluding sqlite internal tables)
      const tables = this.db
        .prepare(
          `
        SELECT name FROM sqlite_master 
        WHERE type='table' 
        AND name NOT LIKE 'sqlite_%'
      `
        )
        .all() as { name: string }[];

      // Disable foreign key constraints temporarily
      this.db.exec("PRAGMA foreign_keys = OFF;");

      // Begin transaction for atomic operation
      this.db.exec("BEGIN TRANSACTION;");

      try {
        // Delete from each table
        for (const table of tables) {
          const tableName = table.name;

          // Get row count before deletion
          const countResult = this.db
            .prepare(`SELECT COUNT(*) as count FROM ${tableName}`)
            .get() as { count: number };
          const rowCount = countResult.count;

          if (rowCount > 0) {
            // Delete all rows
            this.db.prepare(`DELETE FROM ${tableName}`).run();
            tablesEmptied.push(tableName);
            totalRowsDeleted += rowCount;

            console.log(`Emptied table ${tableName}: ${rowCount} rows deleted`);
          }
        }

        // Reset autoincrement counters
        this.db.exec("DELETE FROM sqlite_sequence;");

        // Commit transaction
        this.db.exec("COMMIT;");

        // Re-enable foreign key constraints
        this.db.exec("PRAGMA foreign_keys = ON;");

        // Run VACUUM to reclaim space
        this.db.exec("VACUUM;");

        console.log(
          `Database emptied successfully. ${tablesEmptied.length} tables emptied, ${totalRowsDeleted} rows deleted.`
        );

        return {
          success: true,
          tablesEmptied,
          rowsDeleted: totalRowsDeleted,
        };
      } catch (error) {
        // Rollback on error
        this.db.exec("ROLLBACK;");
        this.db.exec("PRAGMA foreign_keys = ON;");
        throw error;
      }
    } catch (error) {
      console.error("Error emptying database:", error);
      return {
        success: false,
        tablesEmptied: [],
        rowsDeleted: 0,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  close(): void {
    this.db.close();
  }

  // Utility method to get database information
  getDatabaseInfo(): {
    path: string;
    mode: "development" | "production";
    exists: boolean;
    size?: number;
  } {
    const dbPath = this.getDatabasePath();
    const isDev =
      process.env.NODE_ENV === "development" ||
      process.env.ELECTRON_IS_DEV === "true" ||
      !app.isPackaged;

    const info = {
      path: dbPath,
      mode: isDev ? ("development" as const) : ("production" as const),
      exists: fs.existsSync(dbPath),
      size: undefined as number | undefined,
    };

    if (info.exists) {
      try {
        const stats = fs.statSync(dbPath);
        info.size = stats.size;
      } catch (error) {
        console.warn("Could not get database file size:", error);
      }
    }

    return info;
  }
}

// Singleton instance
let dbManager: DatabaseManager | null = null;

export async function getDatabase(): Promise<DatabaseManager> {
  if (!dbManager) {
    dbManager = new DatabaseManager();
    await dbManager.initialize();
  }
  return dbManager;
}

export function closeDatabase(): void {
  if (dbManager) {
    dbManager.close();
    dbManager = null;
  }
}
